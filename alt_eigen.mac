/*  Copyright 2011, 2023 by Barton Willis

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>. */

(load('lrats),load('simplifying), load("integer_sequence"));

/* True iff the expression e is free of floating point (both binary64 and bigfloat)
   numbers. */
float_free_p(e) := if mapatom(e) then not (floatnump(e) or bfloatp(e)) else every(lambda([s], float_free_p(s)), args(e));

simp_assuming(pred,f) := block([prederror : false, bool : is(pred)],
  if bool = true then f 
  else if bool = false then 'unknown
  else simpfuncall('assuming, pred,f));

simplifying('assuming,'simp_assuming)$

/* A simplifying span function. So that it doesn't interfer with the linear algebra
   package, for now, we'll name it sspan (for simplifying span), not span.

   Removes vectors that are explicitly zero, normalizes vectors by removing 
   the gcd of its members, removes explicitly redundant vectors, chooses between
   the vector and its negation, and sorts the vectors. This could do more 
   (optionally do Gram-Schmidt, for example), but for now, this is OK.*/

   simp_sspan([v]) := block([vv : [], normalize],
      normalize : lambda([q], block([w, algebraic : true, matrix_element_transpose : false],
       q : first(args(transpose(q))),
       w : xreduce('gcd,q),
       q : funmake('matrix,[ratsimp(q/w)]),
       q : transpose(q),
       second(sort([q,-q])))),
   for vk in v do (
     if some(lambda([q], q # 0), vk) then push(normalize(vk), vv)),
  simpfunmake('sspan, listify(setify(vv))));
simplifying('sspan,'simp_sspan)$

/* A Gram-Schmidt based method for finding the column space of a matrix M.
   The second argument p should be an equation of the form XXX = YYY. Following
   every projection operation in the Gram-Schmidt process, substitute (using 
   fullratsubst) p into the result of the projection. When the third argument
   orthogonal is true, return an orthognal basis. */
mycolumnspace(M,p,orthogonal) := block([r,c],
  [r,c] : matrix_size(M),
  v : map(lambda([k],col(M,k)), 1 .. c),
  mygramschmidt(v,p,orthogonal));

mynullspace(m,p) := block([nr, nc, acc : [], matrix_element_transpose : false],
  /* nc and nr are the sizes of the transpose of m */
   [nc, nr] : matrix_size(m),
   m : triangularize(addcol(transpose(m), identfor(m))),
   m : fullratsubst(p, m),
   for r in m do (
      r1 : map(lambda([i],equal(inpart(r,i),0)), 1 .. nc),
      r2 : map(lambda([i],inpart(r,i)), (nc+1) .. 2*nc),
      ok : block([prederror : false], xreduce("and",r1)),
      if ok # false then (
         acc : push(assuming(ok, transpose(r2)),acc))),
   acc);
   
/* Apply the Gram-Schmidt process to the list of column vectors with equal size 
   (matrices) in v. The second argument p should be an equation of the form 
   XXX = YYY. Following each projection, substitute (using fullratsubst) p into 
   the result of the projection. 

   The inner product is a.b = transpose(conjugate(a)).b. To do this, we'll locally set 
   matrix_element_transpose to conjugate.

   This function isn't intended to be an user-level function. Accordingly, it doesn't
   check that its arguments are OK. Generally, inappropriate arguments results in
   an unclear error message. */

mygramschmidt(v,p,orthogonal) := block([u : [], basis : [], proj, dot, uk, 
  doallmxops : true, scalarmatrixp : true, matrix_element_transpose : 'conjugate],   
   dot : lambda([a,b], transpose(a).b),
   proj : lambda([a,b], fullratsubst(p, dot(a,b)*a/dot(a,a))),    
   for vk in v do (         
      uk : ratsimp(vk - lsum(proj(s,vk), s, u)),
      uk : fullratsubst(p,uk),
      if some(lambda([s], is(s # 0)), uk) then (
         push(uk, u),
         push(vk, basis))),
  apply(sspan, if orthogonal then u else basis));

/* It's not checked, but the first argument p should be a polynomial in the 
   variable z. When degree(p) <= deg, attempt to find the zeros of p. When
   that is successful, return a list of the solutions; and when solve is
   not successful, solve p for its highest power and return the one member
   list of solutions.*/
maybe_solve(p,z,deg) := block([n, lt, inflag : true, sol,  programmode : true, globalsolve : false, 
   solveexplicit : true, breakup : false, solvenullwarn : false, solvefactors : true],   
   p : ratexpand(p), 
   n : hipow(p,z), 
   sol : if n <= deg then solve(p,z) else [],
   if sol = [] then (    
      lt : ratcoeff(p,z,n),
      [z^n = (lt * z^n - p)/lt])
   else sol)$

/* Let m be a r x r matrix and let p be a polynomial in the variable z. This  function returns a basis for the  
solution to m v = mu * v, where mu is  a zero of the polynomial p. The basis is encoded as the columns of
a matrix.

Instead of handing alt_eigen_h the characteristic polynomial, it's possible to build up the characteristic polynomial 
in the while n > 0 loop. Once the loop finishes, the requirement that lk vanishes determines the characteristic 
polynomial (by solving linear equations).

ratmx : true misbehaves with a non default value or matrix_element_mult. And
ratmx : true doesn't seem to work with nullspace. Let's locally set ratmx to 
false for the call to nullspace.

Some problems run very slowly with ratfac : true (example 
matrix([0,0,0,1,0,1,1,1,0,1],[1,1,0,0,1,0,1,0,1,0],[1,1,1,1,0,0,0,1,0,1],[0,1,1,0,0,1,1,1,1,0],[0,0,1,0,1,0,1,0,1,0],[0,1,0,0,0,0,0,1,0,0],[1,1,0,0,0,0,0,0,1,1],[1,0,1,1,1,0,1,0,0,0],[0,1,1,0,0,1,0,1,0,1],[1,0,0,1,1,0,0,1,0,0])

bug: (can cause trouble for matrices with floating point entries)

 (%i4) rat(1.2) * rat(1/2) - 11/5, keepfloat : true;
 (%o4)/R/ -8.0/5
 (%i5) expand(%,0,0);

For algebraic numbers, sometimes subres is better than spmod.*/

alt_eigen_h(m,r,p,z) := block([vn, n, l, lk, ls, e : funmake('matrix,[]), q, listarith:true, scalarmatrixp:false, 
    doallmxops : true, ratfac : false],
  vn : rat(ident(r)),
  p : rat(p), 
  n : hipow(p,z),  
  p : p / ratcoeff(p,z,n),
  n : n-1,
  l : vn * z^n,
  lk : vn,
  while n > -1 do (
     lk : m . lk + ratcoeff(p, z, n) * vn,  
     n : n -1,
     if n > -1 then l : l + z^n * lk), 

  lk : block([ratmx : false], nullspace(lk)),
  for ls in lk do (
     ls : l . ls,       
     e : addcol(e, ls)),
  e);

/* Find the eigenvectors and eigenvalues of square unblocked matrix; specifically:

    alt_eigen(m, 'var = z, 'maxdegree = n, 'orthogonal = bool)

maxdegree -- try to solve factors of the characteristic poly with degree n or less,
orthogonal -- when true, eigenvectors with geometric multiplicity two or more are sent thru gramm schmidt.

Computing the characteristic polynomial is much faster with ratmx : true. 

When gcd = spmod (the default) and algebraic is true, alt_eigen fails on the matrix 
matrix([1,1/2,%i],[0,1,1/2],[0,1/2,1+%i]). This bug is reported as bug
#4169 spmod bug when algebraic is true. Additionally, with the default values for
gcd (spmod) and algebraic (false), we have
   p :  z^2 + (2*%i - 2)*z - 2*%i, gcd(p, diff(p,z)) # z+%i-1.
So let's set gcd : subres and algebraic : true.

I'm not sure why ratmx gets set to false.*/

alt_eigen(m, [extra]) := block([r, c, n, z : gensym(), p, pp, lk, ord, hp, es : [], cnd, u, ortho, ls, inflag : true,
 doallmxops : true, gcd : subres, algebraic : true],  
  if not matrixp(m) then error("The first argument must be a matrix"),  
  if blockmatrixp(m) then error("The first argument must be an unblocked matrix"),
  if not float_free_p(m) then error("The function alt_eigen does not work for matrices with floating point entries"),

  [r,c] : matrix_size(m),
  if r # c or r = 0 then error("The first argument must be a nonempty square matrix"),
  n : r,   
  hp : assoc('maxdegree, extra, 1), /* hp = highest power polynomial that will be solved */
  if not integerp(hp) then error("The value of 'maxdegree' must be an integer"),
  u : assoc('var, extra, z),
  ortho : assoc('orthogonal, extra, false),
  if not freeof(u,m) then error("The first argument must not depend on ", u),

  p : charpoly(m, z),  
  p : gfactor(p),
  pp : gfactor(p / gcd(p, diff(p,z))),
  cnd : gfactor(resultant(pp,diff(pp,z),z)),
 
  p : if not mapatom(p) and op(p) = "*" then args(p) else [p],
  p : sublist(p, lambda([s], not freeof(z,s))), 
  p : map(gfactor,p),
  for pk in p do ( 
    [pk,ord] : if not mapatom(pk) and op(pk) ="^" then args(pk) else [pk,1],
    lk : alt_eigen_h(m,r,pk,z), 
    lk : fullratsubst(first(maybe_solve(pk,z,1)), lk), 
    pk : maybe_solve(pk, z, hp),
    lk : mycolumnspace(lk, pk, false),
    for pkl in pk do (
       ls : subst(pkl, lk),
       if ortho then ls : mygramschmidt(ls, pkl,true),
       es : cons([pkl, ls], es))),
  assuming(notequal(cnd,0), subst(z=u,es)));